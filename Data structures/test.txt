'''
จงสร้างโครงสร้างข้อมูล Stack ที่มี method ดังต่อไปนี้ 
__str__ สำหรบแสดงข้อมูลที่อยู่ใน stack
push(data) สำหรับเก็บข้อมูล data   
pop() สำหรับนำข้อมูลออก
isEmpty() สำหรับตรวจสอบว่า stack ว่างไหม ถ้าว่าง ให้เป็น True
size() สำหรับแสดงขนาดของ stack ว่ามีข้อมูลกี่ตัว
peek() สำหรับแสดงค่าข้อมูลที่อยู่ที่อยู่บนสุด
bottom() สำหรับแสดงค่าข้อมูลที่อยู่ล่างสุด
โดยเมื่อป้อน 1 แล้วให้ทำงานคำสั่งต่อไปนี้   
    
'''
class Stack():
    def __init__(self):
        self.stack = []

    def __str__(self):
        s = 'Data in Stack is : '
        for i in self.stack:
            s += str(i)+' '
        return s
    
    def push(self,data):
        self.stack.append(data)
    
    def pop(self):
        return self.stack.pop()

    def isEmpty(self):
        return self.stack  is []

    def size(self):
        return len(self.stack)

    def peek(self):
        return self.stack[-1]

    def bottom(self):
        return self.stack[0]



if __name__=='__main__':
    inp = input('Enter choice :')

    s=Stack()
    if inp == '2':
        s.push(100)
        s.push(200)
        s.push(300)
        s.pop()
        print(s)
        print("Stack is Empty :", s.isEmpty())
    elif inp == '1':
        s.push(10)
        s.push(20)
        print(s)
        s.pop()
        s.push(30)
        print("Peek of stack :", s.peek())
        print('Bottom of stack :', s.bottom())
    else:
        s.push(11)
        s.push(22)
        s.push(33)
        s.pop()
        print(s)
        print('Stack size :', s.size())

'''
จงสร้าง class Queue และเขียน method ต่อไปนี้ให้สมบูรณ์ และทำงานตามตัวอย่างได้ 
__str__():  ใช้สำหรับแสดงข้อมูลในคิว
    
__len__():  ใช้สำหรับบอกจำนวนข้อมูลภายในคิว
enQueue(data):  ใช้สำหรับเพิ่มข้อมูลเข้าคิว
deQueue():  ใช้สำหรับนำข้อมูลออกจากคิว
isEmpty():  ตรวจสอบว่าคิวว่างหรือไม่ ถ้าว่าจะแสดงค่า True ถ้าไม่ใช้ แสดง False
'''


class LinkedList:
    class Node:
        def __init__(self,data,next=None):
            self.data = data
            if next is None:
                self.next = None
            else:
                self.next = next

        def __str__(self):
            return str(self.data)

    def __init__(self,head=None):
        if head == None:
            self.head = self.tail = None
            self.size = 0
        else:
            self.head = head
            t = self.head
            self.size = 1
            while t.next != None:
                t= t.next
                self.size +=1
            self.tail =t
    
    def __str__(self):
        s ='Linked data : '
        p = self.head
        while p !=None:
            s +=str(p.data)+' '
            p = p.next
        return s

    def __len__(self):
        return self.size    


class Queue:

    def __init__(self):
        self.q = LinkedList()

    def __str__(self):
        if self.isEmpty():
            return 'Empty Queue'
        s = 'Queue data : '
        for i in range(len(self.q)):
            s += str(self.q.nodeAt(i).data) + ' '
        return s

    def __len__(self):
        return len(self.q)

    def enQueue(self, data):
        self.q.append(data)

    def deQueue(self):
        self.q.removeHead()

    def isEmpty(self):
        return self.q.isEmpty()


if __name__ == '__main__':
    inp = input('Enter choice : ')

    q = Queue()
    if inp == '1':
        q1 = Queue()
        q1.enQueue(10)
        q1.enQueue(20)
        q1.enQueue(30)
        print(q1)
        q1.deQueue()
        q1.enQueue(40)
        print("Size of Queue :", len(q1))
        print(q1)
    elif inp == '2':
        q1 = Queue()
        q1.enQueue(100)
        q1.enQueue(200)
        q1.enQueue(300)
        q1.deQueue()
        print(q1)
        print("Queue is Empty :", q1.isEmpty())
    else:
        q1 = Queue()
        q1.enQueue(11)
        q1.enQueue(22)
        q1.enQueue(33)
        q1.deQueue()
        q1.deQueue()
        q1.deQueue()
        print(q1)
        print("Size of Queue :", len(q1))
        print("Queue is Empty :", q1.isEmpty())

class LinkedList:
    class Node:
        def __init__(self, data, next=None):
            self.data = data
            if next is None:
                self.next = None
            else:
                self.next = next

        def __str__(self):
            return str(self.data)

    def __init__(self, head=None):
        if head == None:
            self.head = self.tail = None
            self.size = 0
        else:
            self.head = head
            t = self.head
            self.size = 1
            while t.next != None:
                t = t.next
                self.size += 1
            self.tail = t

    def __str__(self):
        s = 'Linked data : '
        p = self.head
        while p != None:
            s += str(p.data)+' '
            p = p.next
        return s

    def __len__(self):
        return self.size

    def append(self, data):
        p = self.Node(data)
        if self.head == None:
            self.head = self.tail = p
        else:
            t = self.tail
            t.next = p
            self.tail = p
        self.size += 1

    def removeHead(self):
        if self.head == None:
            return
        if self.head.next == None:
            p = self.head
            self.head = None
        else:
            p = self.head
            self.head = self.head.next
        self.size -= 1
        return p.data

    def removeDup(self):
        dup=[]
        if self.head == None :return
        p= self.head
        while p.next != None:
            dup.append(p.data)
            if p.next.data in dup:
                p.next = p.next.next
            else:
                p = p.next

    def isEmpty(self):
        return self.size == 0

    def nodeAt(self, i):
        p = self.head
        for j in range(i):
            p = p.next
        return p

if __name__ == '__main__':
    inputlist = [int(e) for e in input('Enter numbers : ').split()]

    l = LinkedList()
    for data in inputlist:
        l.append(data)
    print("Linkedlist Before removeDuplicate")
    print(l)
    l.removeDup()
    print("Linkedlist After removeDuplicate")
    print(l)

'''
จาก class LinkedList ในข้อ 2 จงเขียน method contentEquivalence  เพื่อตรวจสอบว่า linked list ที่รับเข้ามากับ linked list 
ของตัวมันเองมีคุณสมบัตินี้หรือไม่  โดยจะ return True ถ้ามีคุณสมบัตินี้ ถ้าไม่ใช่เป็น False
โดยคุณสมบัติ content equivalence(CV) เป็นดังนี้ เมื่อ linked list มีจำนวนโหนดเท่ากันและโหนดต่าง ๆ ของทั้ง 2 lists 
มีค่าเท่ากันทุกโหนด โดยที่ตำแหน่งของโหนดที่เก็บข้อมูลของทั้ง 2 lists อาจแตกต่างกันได้เช่น [1,2,4,8] กับ [4,1,2,8] 
มีคุณสมบัติ CV ในขณะที่ [1,2,4,8] กับ [3,4,2,8] ไม่มีคุณสมบัติ CV
***ห้ามใช้ function sorted() และการจัดการข้อมูลด้วยชนิดข้อมูล list ของ python ***
'''

class LinkedList:
    class Node :
        def __init__(self,data,next = None) :
            self.data = data
            if next is None :
                self.next = None
            else :
                self.next = next
                
        def __str__(self) :
            return str(self.data)

    def __init__(self,head = None):
        if head == None:
                self.head = self.tail = None
                self.size = 0
        else:
            self.head = head
            t = self.head        
            self.size = 1
            while t.next != None :
                t = t.next
                self.size += 1
            self.tail = t
            
    def __str__(self) :
        s = 'Linked data : '
        p = self.head
        while p != None :
            s += str(p.data)+' '
            p = p.next
        return s

    def __len__(self) :
        return self.size
    
    def append(self, data):
        p = self.Node(data)
        if self.head == None:
            self.head = self.tail = p
        else:
            t = self.tail
            t.next = p   
            self.tail =p  
        self.size += 1

    def removeHead(self) :
        if self.head == None : return
        if self.head.next == None :
            p = self.head
            self.head = None
        else :
            p = self.head
            self.head = self.head.next
        self.size -= 1
        return p.data

    def contentEquivalence(self, lst):
        if self.size != len(lst):
            return False
        for i in range(self.size):
            if self.nodeAt(i).data != lst.nodeAt(i).data:
                return False
        return True

    def appendSort(self, data):
        p = self.Node(data)
        self.size += 1
        if self.head == None:
            self.head = self.tail = p
        else:
            if data < self.head.data:
                p.next = self.head
                self.head = p
                return
            if data > self.tail.data:
                self.tail.next = p
                self.tail = p
                return

            cur = self.head
            while cur.next != None and cur.next.data < data:
                cur = cur.next
            p.next = cur.next
            cur.next = p
    
    def isEmpty(self) :
        return self.size == 0
    
    def nodeAt(self,i) :
        p = self.head
        for j in range(i) :
            p = p.next
        return p

if __name__ == '__main__':
    inputlist = input('List1,List2 : ').split(',')

    list1 = LinkedList()
    list2 = LinkedList()

    for data in inputlist[0].split():
        list1.appendSort(data)

    for data in inputlist[1].split():
        list2.appendSort(data)

    print('List1 content Equivalence List2 :', list1.contentEquivalence(list2))

'''
จาก class LinkedList ในข้อ 2 ให้นักศึกษาใช้ class LinkedList  ข้างต้นเขียนโปรแกรมเพื่อหาค่าฐานนิยม (mode)
และแสดงผลดังตัวอย่าง โดยให้ใช้โครงสร้างข้อมูลแบบ LinkedList เท่านั้น 
***ห้ามใช้ function sorted()  ***
ตัวอย่าง output 
Enter numbers : 7 9 3 2 1 2 3 4 8 9 3 15
Output :
Linked data : 1 2 2 3 3 3 4 7 8 9 9 15
Amount of data = 12
Mode = 3
 
Enter numbers : 7 6 74 44 6 37 55 35 3 31 3 10
Output :
Linked data : 3 3 6 6 7 10 31 35 37 44 55 74
Amount of data = 12
Mode = 3, 6
Enter numbers : 7 74 44 6 37 55 35 31 3 10 22 12
Output :
Linked data : 3 6 7 10 12 22 31 35 37 44 55 74
Amount of data = 12
Mode is not available.
'''

class LinkedList:
    class Node :
        def __init__(self,data,next = None) :
            self.data = data
            if next is None :
                self.next = None
            else :
                self.next = next
                
        def __str__(self) :
            return str(self.data)

    def __init__(self,head = None):
        if head == None:
                self.head = self.tail = None
                self.size = 0
        else:
            self.head = head
            t = self.head        
            self.size = 1
            while t.next != None :
                t = t.next
                self.size += 1
            self.tail = t
            
    def __str__(self) :
        s = 'Linked data : '
        p = self.head
        while p != None :
            s += str(p.data)+' '
            p = p.next
        return s

    def __len__(self) :
        return self.size

    def removeHead(self) :
        if self.head == None : return
        if self.head.next == None :
            p = self.head
            self.head = None
        else :
            p = self.head
            self.head = self.head.next
        self.size -= 1
        return p.data

    def append(self, data):
        p = self.Node(data)
        self.size += 1
        if self.head == None:
            self.head = self.tail = p
        else:
            if data < self.head.data:
                p.next = self.head
                self.head = p
                return
            if data > self.tail.data:
                self.tail.next = p
                self.tail = p
                return

            cur = self.head
            while cur.next != None and cur.next.data < data:
                cur = cur.next
            p.next = cur.next
            cur.next = p
    
    def isEmpty(self) :
        return self.size == 0
    
    def nodeAt(self,i) :
        p = self.head
        for j in range(i) :
            p = p.next
        return p

def findMode(l):
    mode = {}
    maxx = 0
    check = LinkedList()
    for i in range(len(l)):
        data = l.nodeAt(i).data
        mode[str(data)] = mode.get(str(data), 0) + 1
        if mode[str(data)] > maxx:
            maxx = mode[str(data)]
        dup = False
        for i in range(len(check)):
            if check.nodeAt(i).data == data:
                dup = True
                break
        if dup:
            continue
        check.append(data)

    counter = 0
    modelist = LinkedList()
    for i in range(len(check)):
        data = check.nodeAt(i).data
        if mode[str(data)] == maxx:
            counter += 1
            modelist.append(data)

    if counter == len(l):
        print('Mode is not available.')
    else:
        print('Mode =  ', end = '')
        for i in range(len(modelist)):
            print(modelist.nodeAt(i).data, end = ' ')
            

if __name__ == '__main__':
    inputlist = [int(e) for e in input('Enter numbers : ').split()]

    l = LinkedList()

    for data in inputlist:
        l.append(data)

    print("Output :")
    print(l)
    print('Amount of data =', len(l))
    findMode(l)